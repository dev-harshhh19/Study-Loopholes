<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page Replacement Algorithms - OS Practical</title>
    <link rel="stylesheet" href="../global.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Inconsolata&display=swap" rel="stylesheet">
    <style>
        .main-container {
            display: flex;
            height: calc(100vh - var(--header-height));
        }
        .content {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
        }
        .description {
            margin-bottom: 30px;
            padding: 20px;
            background-color: var(--card-background);
            border-radius: 8px;
            border-left: 4px solid var(--accent-color);
        }
        .algorithm-section {
            margin: 40px 0;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        .algorithm-title {
            color: var(--accent-color);
            margin-bottom: 15px;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
        }
        .code-block {
            position: relative;
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 5px;
            margin-top: 20px;
            border: 1px solid #444;
        }
        pre {
            margin: 0;
            font-family: 'Inconsolata', monospace;
            font-size: 14px;
            color: #d4d4d4;
            white-space: pre-wrap;
        }
        .copy-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #444;
            color: var(--text-color);
            transition: background-color 0.3s ease;
        }
        .copy-btn:hover {
            background-color: #555;
        }
        .download-btn {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }
        .download-btn:hover {
            background-color: #0056b3;
        }
        .algorithm-description {
            margin-bottom: 15px;
            padding: 15px;
            background-color: rgba(0, 123, 255, 0.1);
            border-left: 3px solid var(--accent-color);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1><a href="OS.html">OS Practicals</a> / Page Replacement Algorithms</h1>
    </header>

    <div class="main-container">
        <main class="content">
            <div class="description">
                <h2>Page Replacement Algorithms</h2>
                <p>
                    Page replacement algorithms are used in operating systems to decide which page should be 
                    removed from memory when a new page needs to be loaded and memory is full. These algorithms 
                    are crucial for virtual memory management and system performance optimization.
                </p>
                <p>
                    <strong>This practical covers three fundamental algorithms:</strong>
                </p>
                <ul>
                    <li><strong>FIFO (First In First Out):</strong> Removes the oldest page in memory</li>
                    <li><strong>LRU (Least Recently Used):</strong> Removes the page that hasn't been used for the longest time</li>
                    <li><strong>Optimal:</strong> Removes the page that will not be used for the longest time in the future</li>
                </ul>
            </div>

            <!-- FIFO Algorithm -->
            <div class="algorithm-section">
                <h2 class="algorithm-title">1. FIFO (First In First Out) Page Replacement</h2>
                <div class="algorithm-description">
                    <strong>FIFO Algorithm:</strong> The simplest page replacement algorithm that maintains pages in a queue. 
                    When a page fault occurs, the algorithm removes the page that has been in memory the longest (first in, first out).
                </div>
                <div class="code-block">
                    <pre><code>from collections import deque

class FIFOPageReplacement:
    def __init__(self, num_frames):
        self.num_frames = num_frames  # Number of frames in memory
        self.memory = []  # List to store pages in memory
        self.page_faults = 0  # Counter for page faults
        self.page_order = deque()  # To track the order of pages for FIFO

    def access_page(self, page):
        if page in self.memory:
            print(f"Page {page} is already in memory (Hit).")
            return False  # No page fault

        # If memory is full, replace the oldest page
        if len(self.memory) == self.num_frames:
            oldest_page = self.page_order.popleft()  # Remove the oldest page
            self.memory.remove(oldest_page)
            print(f"Page {oldest_page} removed from memory (FIFO).")

        # Add the new page
        self.memory.append(page)
        self.page_order.append(page)
        self.page_faults += 1
        print(f"Page {page} loaded into memory (Page fault).")
        return True

    def display_memory(self):
        print(f"Current Memory: {self.memory}")
        print(f"Page Faults: {self.page_faults}")


# Example usage of FIFO with user input
if __name__ == "__main__":
    num_frames = int(input("Enter the number of frames in memory: "))  # Get number of frames from the user
    fifo = FIFOPageReplacement(num_frames=num_frames)

    # Taking input for page sequence
    pages_input = input("Enter a sequence of page numbers separated by spaces: ")
    pages = list(map(int, pages_input.split()))  # Convert the input into a list of integers

    for page in pages:
        fifo.access_page(page)
        fifo.display_memory()</code></pre>
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                </div>
                <button class="download-btn" onclick="downloadFIFO()">Download FIFO Algorithm</button>
            </div>

            <!-- LRU Algorithm -->
            <div class="algorithm-section">
                <h2 class="algorithm-title">2. LRU (Least Recently Used) Page Replacement</h2>
                <div class="algorithm-description">
                    <strong>LRU Algorithm:</strong> This algorithm replaces the page that has not been used for the longest period of time. 
                    It assumes that pages used recently will likely be used again soon.
                </div>
                <div class="code-block">
                    <pre><code>from collections import deque

class LRUPageReplacement:
    def __init__(self, num_frames):
        self.num_frames = num_frames  # Number of frames in memory
        self.memory = []  # List to store pages in memory
        self.page_faults = 0  # Counter for page faults

    def access_page(self, page):
        if page in self.memory:
            # If the page is already in memory, it's a hit
            print(f"Page {page} is already in memory (Hit).")
            # Move the page to the most recent position (most recently used)
            self.memory.remove(page)
            self.memory.append(page)
            return False

        # If memory is full, remove the least recently used page (LRU)
        if len(self.memory) == self.num_frames:
            lru_page = self.memory.pop(0)  # Remove the LRU page (the first page)
            print(f"Page {lru_page} removed from memory (LRU).")

        # Add the new page
        self.memory.append(page)
        self.page_faults += 1
        print(f"Page {page} loaded into memory (Page fault).")
        return True

    def display_memory(self):
        print(f"Current Memory: {self.memory}")
        print(f"Page Faults: {self.page_faults}")


# Example usage of LRU with user input
if __name__ == "__main__":
    num_frames = int(input("Enter the number of frames in memory: "))  # Get number of frames from the user
    lru = LRUPageReplacement(num_frames=num_frames)

    # Taking input for page sequence
    pages_input = input("Enter a sequence of page numbers separated by spaces: ")
    pages = list(map(int, pages_input.split()))  # Convert the input into a list of integers

    for page in pages:
        lru.access_page(page)
        lru.display_memory()</code></pre>
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                </div>
                <button class="download-btn" onclick="downloadLRU()">Download LRU Algorithm</button>
            </div>

            <!-- Optimal Algorithm -->
            <div class="algorithm-section">
                <h2 class="algorithm-title">3. Optimal Page Replacement</h2>
                <div class="algorithm-description">
                    <strong>Optimal Algorithm:</strong> This algorithm replaces the page that will not be used for the longest period in the future. 
                    It provides the minimum number of page faults but requires future knowledge of page requests.
                </div>
                <div class="code-block">
                    <pre><code>def optimal_page_replacement(num_frames, pages):
    memory = []  # List to store pages in memory
    page_faults = 0  # Counter for page faults
    
    for i in range(len(pages)):
        page = pages[i]

        # If the page is already in memory, it's a hit
        if page in memory:
            print(f"Page {page} is already in memory (Hit).")
            continue

        # If there is space in memory, add the page
        if len(memory) < num_frames:
            memory.append(page)
            page_faults += 1
            print(f"Page {page} loaded into memory (Page fault).")
        else:
            # If memory is full, we need to replace a page
            # Find the page that will not be used for the longest time
            farthest_use = -1
            page_to_remove = None

            # Check for each page in memory, find when it will be used next
            for m in memory:
                if m not in pages[i + 1:]:  # If page won't be used again
                    page_to_remove = m
                    break
                else:
                    # Get the index of the next occurrence of the page in the future
                    next_use = pages[i + 1:].index(m) if m in pages[i + 1:] else float('inf')
                    if next_use > farthest_use:
                        farthest_use = next_use
                        page_to_remove = m

            # Remove the selected page and add the new one
            memory.remove(page_to_remove)
            memory.append(page)
            page_faults += 1
            print(f"Page {page_to_remove} removed from memory (Optimal).")
            print(f"Page {page} loaded into memory (Page fault).")
    
        print(f"Current Memory: {memory}")
    
    print(f"Total Page Faults: {page_faults}")


# Example usage of Optimal Page Replacement
if __name__ == "__main__":
    num_frames = int(input("Enter the number of frames in memory: "))  # Get number of frames from the user
    pages_input = input("Enter a sequence of page numbers separated by spaces: ")
    pages = list(map(int, pages_input.split()))  # Convert the input into a list of integers

    optimal_page_replacement(num_frames, pages)</code></pre>
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                </div>
                <button class="download-btn" onclick="downloadOptimal()">Download Optimal Algorithm</button>
            </div>
        </main>
    </div>

    <script>
        function copyCode(button) {
            const pre = button.previousElementSibling;
            const code = pre.querySelector('code').textContent;
            navigator.clipboard.writeText(code).then(() => {
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = 'Copy';
                }, 2000);
            });
        }

        function downloadFIFO() {
            const code = `from collections import deque

class FIFOPageReplacement:
    def __init__(self, num_frames):
        self.num_frames = num_frames  # Number of frames in memory
        self.memory = []  # List to store pages in memory
        self.page_faults = 0  # Counter for page faults
        self.page_order = deque()  # To track the order of pages for FIFO

    def access_page(self, page):
        if page in self.memory:
            print(f"Page {page} is already in memory (Hit).")
            return False  # No page fault

        # If memory is full, replace the oldest page
        if len(self.memory) == self.num_frames:
            oldest_page = self.page_order.popleft()  # Remove the oldest page
            self.memory.remove(oldest_page)
            print(f"Page {oldest_page} removed from memory (FIFO).")

        # Add the new page
        self.memory.append(page)
        self.page_order.append(page)
        self.page_faults += 1
        print(f"Page {page} loaded into memory (Page fault).")
        return True

    def display_memory(self):
        print(f"Current Memory: {self.memory}")
        print(f"Page Faults: {self.page_faults}")


# Example usage of FIFO with user input
if __name__ == "__main__":
    num_frames = int(input("Enter the number of frames in memory: "))  # Get number of frames from the user
    fifo = FIFOPageReplacement(num_frames=num_frames)

    # Taking input for page sequence
    pages_input = input("Enter a sequence of page numbers separated by spaces: ")
    pages = list(map(int, pages_input.split()))  # Convert the input into a list of integers

    for page in pages:
        fifo.access_page(page)
        fifo.display_memory()`;
            
            downloadFile(code, 'fifo_page_replacement.py');
        }

        function downloadLRU() {
            const code = `from collections import deque

class LRUPageReplacement:
    def __init__(self, num_frames):
        self.num_frames = num_frames  # Number of frames in memory
        self.memory = []  # List to store pages in memory
        self.page_faults = 0  # Counter for page faults

    def access_page(self, page):
        if page in self.memory:
            # If the page is already in memory, it's a hit
            print(f"Page {page} is already in memory (Hit).")
            # Move the page to the most recent position (most recently used)
            self.memory.remove(page)
            self.memory.append(page)
            return False

        # If memory is full, remove the least recently used page (LRU)
        if len(self.memory) == self.num_frames:
            lru_page = self.memory.pop(0)  # Remove the LRU page (the first page)
            print(f"Page {lru_page} removed from memory (LRU).")

        # Add the new page
        self.memory.append(page)
        self.page_faults += 1
        print(f"Page {page} loaded into memory (Page fault).")
        return True

    def display_memory(self):
        print(f"Current Memory: {self.memory}")
        print(f"Page Faults: {self.page_faults}")


# Example usage of LRU with user input
if __name__ == "__main__":
    num_frames = int(input("Enter the number of frames in memory: "))  # Get number of frames from the user
    lru = LRUPageReplacement(num_frames=num_frames)

    # Taking input for page sequence
    pages_input = input("Enter a sequence of page numbers separated by spaces: ")
    pages = list(map(int, pages_input.split()))  # Convert the input into a list of integers

    for page in pages:
        lru.access_page(page)
        lru.display_memory()`;
            
            downloadFile(code, 'lru_page_replacement.py');
        }

        function downloadOptimal() {
            const code = `def optimal_page_replacement(num_frames, pages):
    memory = []  # List to store pages in memory
    page_faults = 0  # Counter for page faults
    
    for i in range(len(pages)):
        page = pages[i]

        # If the page is already in memory, it's a hit
        if page in memory:
            print(f"Page {page} is already in memory (Hit).")
            continue

        # If there is space in memory, add the page
        if len(memory) < num_frames:
            memory.append(page)
            page_faults += 1
            print(f"Page {page} loaded into memory (Page fault).")
        else:
            # If memory is full, we need to replace a page
            # Find the page that will not be used for the longest time
            farthest_use = -1
            page_to_remove = None

            # Check for each page in memory, find when it will be used next
            for m in memory:
                if m not in pages[i + 1:]:  # If page won't be used again
                    page_to_remove = m
                    break
                else:
                    # Get the index of the next occurrence of the page in the future
                    next_use = pages[i + 1:].index(m) if m in pages[i + 1:] else float('inf')
                    if next_use > farthest_use:
                        farthest_use = next_use
                        page_to_remove = m

            # Remove the selected page and add the new one
            memory.remove(page_to_remove)
            memory.append(page)
            page_faults += 1
            print(f"Page {page_to_remove} removed from memory (Optimal).")
            print(f"Page {page} loaded into memory (Page fault).")
    
        print(f"Current Memory: {memory}")
    
    print(f"Total Page Faults: {page_faults}")


# Example usage of Optimal Page Replacement
if __name__ == "__main__":
    num_frames = int(input("Enter the number of frames in memory: "))  # Get number of frames from the user
    pages_input = input("Enter a sequence of page numbers separated by spaces: ")
    pages = list(map(int, pages_input.split()))  # Convert the input into a list of integers

    optimal_page_replacement(num_frames, pages)`;
            
            downloadFile(code, 'optimal_page_replacement.py');
        }

        function downloadFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>